Динамическая типизация — тип переменной определяется в момент присваивания.
x = 10      # int
x = "текст" # теперь str (ошибки нет)

Основные типы:
int, float — числа (3, 3.14)
str — строки ("Привет", 'мир')
bool — True/False
list — список ([1, 2, 3])
dict — словарь ({"ключ": "значение"})
tuple — кортеж ((1, 2), неизменяемый)
set — множество ({1, 2, 3}, уникальные элементы)
a = [1, 2, 3]
b = a # Это не копия! Теперь b и a ссылаются на один список
b.append(4)
print(a)  # [1, 2, 3, 4] (!)

Условные операторы:
if x > 0:
    print("Положительное")
elif x == 0:
    print("Ноль")
else:
    print("Отрицательное")

Тернарный оператор:
result = "Чётное" if x % 2 == 0 else "Нечётное"

Циклы:
for i in range(5):       # 0, 1, 2, 3, 4
for num in [10, 20, 30]: # Перебор элементов
for key, value in {"a": 1, "b": 2}.items():  # Итерация по словарю

while x < 100:
    x *= 2

break — выход из цикла.
continue — переход к следующей итерации.
else в цикле — выполняется, если не было break.

Функция — это блок кода, который:
Выполняет конкретную задачу,
может принимать данные (аргументы),
Может возвращать результат.

Параметры — переменные в объявлении функции.
Аргументы — конкретные значения, которые передаются при вызове.
Типы параметров:
Позиционные — должны передаваться в правильном порядке
Именованные — передаются по имени параметра
По умолчанию — параметры, которые можно не указывать

Функция завершается при встрече return.
Можно вернуть любое значение (или ничего — return None).

Области видимости:
Локальные и глобальные переменные:
Локальные — существуют только внутри функции,
Глобальные — объявлены вне функций.

*args — принимает любое количество позиционных аргументов (сохраняет в кортеж)
**kwargs — принимает любое количество именованных аргументов (сохраняет в словарь)

Аннотации типов (Type Hints)
Помогают понять, какие типы данных ожидаются:

def send_email(to: str, subject: str, body: str) -> bool:
    """Отправляет email. Возвращает True при успехе."""
    # ... код функции ...
    return True
Преимущества:
Лучшая читаемость,
IDE подсказывает типы,
Используется в современном Django.

Для работы с файлами используется функция open():
file = open("example.txt", "r")  # Открытие файла для чтения
content = file.read()           # Чтение содержимого
file.close()                    # Закрытие файла (важно!)
Проблема: Если забыть close(), файл останется заблокированным.
Решение: Контекстный менеджер (with):
with open("example.txt", "r") as file:
    content = file.read()
Режимы открытия файлов

"r"	Чтение (по умолчанию). Ошибка, если файл не существует.
"w"	Запись. Перезаписывает файл, если он существует. Создаёт, если нет.
"a"	Дозапись в конец файла. Создаёт файл, если нет.
"r+" Чтение и запись. Курсор в начале файла.
"w+" Чтение и запись. Перезаписывает файл.
"a+" Чтение и дозапись. Курсор в конце файла.

Способы чтения:
file.read() — читает весь файл в одну строку.
file.readline() — читает одну строку.
file.readlines() — возвращает список строк.
with open("data.txt", "r") as file:
    for line in file:              # Читаем файл построчно
        print(line.strip())       # .strip() удаляет \n в конце

Всегда указывайте кодировку (особенно для русского текста):
with open("file.txt", "r", encoding="utf-8") as file:
    content = file.read()

Всегда обрабатывайте возможные ошибки:
try:
    with open("missing_file.txt", "r") as file:
        content = file.read()
except FileNotFoundError:
    print("Файл не найден!")
except IOError as e:
    print(f"Ошибка ввода/вывода: {e}")

функция, которая записывает содержимое двух файлов в третий
def merge_files(file1_path, file2_path, output_path):
    with open(file1_path, "r") as file1, open(file2_path, "r") as file2:
        content = file1.read() + "\n" + file2.read()

    with open(output_path, "w") as out_file:
        out_file.write(content)

Объектно-Ориентированное Программирование — это способ организации кода вокруг объектов
Класс — это шаблон для создания объектов.
Объект — экземпляр класса, конкретная реализация.
Атрибуты — характеристики объекта.
Методы — функции, которые работают с объектом.
__init__ — это конструктор, он вызывается при создании объекта.
self — ссылка на текущий объект.
Инкапсуляция — объединение данных и методов в классе, скрытие деталей реализации (например, через _ и __).
Наследование — создание дочерних классов на основе родительских (class Child(Parent)).
Полиморфизм — возможность использовать один интерфейс для разных типов (переопределение методов, перегрузка операторов).
Абстракция — упрощение сложности через создание абстрактных классов и методов (from abc import ABC, abstractmethod).
